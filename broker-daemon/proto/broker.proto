/**
 * This is the API definition for the Broker Daemon RPC Server.
 *
 * The Broker (or Broker Daemon) is an open source piece of software that allows anyone to
 * operate a node that keeps control of the private keys to their cryptocurrency (like Bitcoin and Litecoin)
 * and use [SparkSwap](http://sparkswap.com) to trade those currencies.
 *
 * The Broker runs as a daemon on a machine you control, and you direct it to take action through the RPC Server.
 * The Broker is responsible for translating typical trading behavior (e.g. market buys) into actions on the SparkSwap Relayer (e.g. a BTC/LTC swap on the Lightning Network).
 *
 * The Broker exposes a [gRPC service](http://grpc.io) which has support for [client libraries in many languages](https://grpc.io/about/#osp).
 *
 * The easiest way to interact with the Broker is through the [Broker CLI](https://github.com/sparkswap/broker-cli).
 *
 * For more information on the Broker, see:
 *
 *  - [Installing the BrokerDaemon](https://github.com/sparkswap/broker)
 *  - [Broker CLI](https://github.com/sparkswap/broker-cli)
 *  - [BrokerDaemon GitHub repository](https://github.com/sparkswap/broker)
 *
 * For more information on SparkSwap as a whole, see:
 *
 *  - [SparkSwap Homepage](https://sparkswap.com)
 *  - [SparkSwap Documentation](https://sparkswap.com/docs)
 *  - [SparkSwap Chat](https://sparkswap.com/chat)
 *
 * > Setting up to use the examples:
 *
 * ```javascript
 * // This documentation makes use of the grpc and grpc-caller libraries on npm.
 * // The remainder of the docs assumes this setup step.
 * const grpc = require('grpc')
 * const PROTO_OPTIONS = {
 *   convertFieldsToCamelCase: true,
 *   binaryAsBase64: true,
 *   longsAsStrings: true,
 *   enumsAsStrings: true
 * }
 * const brokerProto = grpc.load('/path/to/broker.proto', 'proto', PROTO_OPTIONS)
 * ```
 *
 * ```shell
 * > npm install -g https://github.com/sparkswap/broker-cli
 * > sparkswap -h
 * ```
 */
syntax = "proto3";
package broker.rpc;
import "google/api/annotations.proto";

// import "google/protobuf/empty.proto";
// normally we would us the above import statement, but the node.js grpc doesn't import
// the standard types and so it throws an error message saying that it can't find google/protobuf.empty.proto
// Instead, we define our own Empty message that is equivalent.
message google {
    message protobuf {
        message Empty {
        }
    }
}

/**
 * Side is one of the two sides of any market.
 */
enum Side {
  // A BID is the buy side of a market.
  BID = 0;
  // An ASK is the sell side of a market.
  ASK = 1;
}


// Statuses of the relayer
enum RelayerStatuses {
  // Relayer is available
  RELAYER_OK = 0;
  // Relayer is not available
  RELAYER_UNAVAILABLE = 1;
}

// Statuses of an engine
enum EngineStatuses {
  // Default state of the engine
  UNKNOWN = 0;
  // Engine is unavailable
  UNAVAILABLE = 1;
  // Wallet does not exist
  NEEDS_WALLET = 2;
  // Wallet exists but is not locked
  LOCKED = 3;
  // Wallet is unlocked but the configuration of the node and chain sync status are not known
  UNLOCKED = 4;
  // Engine is not yet synced to chain
  NOT_SYNCED = 5;
  // Engine is validated and ready for use
  VALIDATED = 6;
}

/**
 * EngineStatus provides the status of an engine for a currency.
 */
message EngineStatus {
  // The common symbol that the engine is responsible for, e.g. `BTC` or `LTC`
  string symbol = 1;
  // The status of the engine
  EngineStatuses status = 2;
}

// Statuses of an orderbook
enum OrderbookStatuses {
  // Orderbook is synced
  ORDERBOOK_OK = 0;
  // Orderbook is not synced
  ORDERBOOK_NOT_SYNCED = 1;
}

/**
 * OrderbookStatus provides the status of an orderbook for a market.
 */
message OrderbookStatus {
  // The market for the orderbook, e.g. `BTC/LTC`
  string market = 1;
  // The status of the market
  OrderbookStatuses status = 2;
}

/**
 * HealthCheckResponse provides information on the health of a BrokerDaemon.
 */
message HealthCheckResponse {
  // The status of every engine available on the BrokerDaemon.
  repeated EngineStatus engine_status = 1;
  // The status of the relayer this BrokerDaemon is connected to, either `'OK'` or the error message returned when connecting to it.
  RelayerStatuses relayer_status = 2;
  // The status of every orderbook available on the BrokerDaemon.
  repeated OrderbookStatus orderbook_status = 3;
}

/**
 * GetIdentityResponse provides the Public Key of the BrokerDaemon
 */
message GetIdentityResponse {
  // The public key of the BrokerDaemon used to authenticate interactions with the Relayer
  string public_key = 1;
}

message RegisterResponse {
  // the Identifier assigned by the Relayer for the Entity associated with the provided Public Key
  string entity_id = 1;
  // URL to complete user registration
  string url = 2;
}

/**
 * The AdminService performs administrative tasks on the BrokerDaemon.
 *
 * ```javascript
 * const address = 'localhost:27492'
 * const adminService = new brokerProto.AdminService(address, grpc.credentials.createInsecure())
 * ```
 */
service AdminService {
  /**
   * The HealthCheck returns a status of all of the components of the BrokerDaemon.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * adminService.healthCheck({}, { deadline }, (err, { engineStatus, relayerStatus }) => {
   *   if (err) return console.error(err)
   *   console.log({ engineStatus, relayerStatus })
   * })
   * ```
   *
   * ```shell
   * > sparkswap healthcheck
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * {
   *   "engineStatus": [
   *     {
   *       "symbol": "BTC",
   *       "status": "OK"
   *     },
   *     {
   *       "symbol": "LTC",
   *       "status": "OK"
   *     },
   *   ],
   *   "orderbookStatus": [
   *     {
   *       "market": "BTC/LTC",
   *       "status": "OK"
   *     }
   *   ],
   *   "relayerStatus": "OK"
   * }
   * ```
   *
   * ```shell
   * Sparkswap Healthcheck
   *
   * ┌───────────────────┬───────────────────┐
   * │ Component         │ Status            │
   * ├───────────────────┼───────────────────┤
   * │ BTC Engine        │ OK                │
   * ├───────────────────┼───────────────────┤
   * │ LTC Engine        │ OK                │
   * ├───────────────────┼───────────────────┤
   * │ Relayer           │ OK                │
   * ├───────────────────┼───────────────────┤
   * │ BTC/LTC Orderbook │ OK                │
   * ├───────────────────┼───────────────────┤
   * │ Daemon            │ OK                │
   * └───────────────────┴───────────────────┘
   * ```
   */
  rpc HealthCheck (google.protobuf.Empty) returns (HealthCheckResponse) {
    option (.google.api.http) = {
      get: "/v1/admin/healthcheck"
    };
  }

  /**
   * GetIdentity returns the Public Key the BrokerDaemon uses to interact with the Relayer.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * adminService.getIdentity({}, { deadline }, (err, { publicKey }) => {
   *   if (err) return console.error(err)
   *   console.log({ publicKey })
   * })
   * ```
   *
   * ```shell
   * > sparkswap id
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * {
   *   "publicKey": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVbt2b1JHw7Kg2I9340n8jA5ycbyH\neucZq00VNANqsoUSfw2iqRkM4OLVdUZ22YGR+mN/0CgIIwiWxNE6g58V+g==\n-----END PUBLIC KEY-----\n"
   * }
   * ```
   *
   * ```shell
   * -----BEGIN PUBLIC KEY-----
   * MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEVbt2b1JHw7Kg2I9340n8jA5ycbyH
   * eucZq00VNANqsoUSfw2iqRkM4OLVdUZ22YGR+mN/0CgIIwiWxNE6g58V+g==
   * -----END PUBLIC KEY-----
   * ```
   */
  rpc GetIdentity (google.protobuf.Empty) returns (GetIdentityResponse) {
    option (.google.api.http) = {
      get: "/v1/admin/identity"
    };
  }

  /**
   * Register provides the Broker's identity (via Public Key) to the Relayer
   * and returns the Relayer-assigned entityId for the Broker as well as
   * the URL to use to complete user registration.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * adminService.register({ }, { deadline }, (err, { entityId, url }) => {
   *   if (err) return console.error(err)
   *   console.log({ entityId, url })
   * })
   * ```
   *
   * ```shell
   * > sparkswap register
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * {
   *   "entityId": "BAfwIYxkUqHJ3pLLh60AAQj3",
   *   "url": "https://sparkswap.com/register/BAfwIYxkUqHJ3pLLh60AAQj3"
   * }
   * ```
   *
   * ```shell
   * ┌─────────────────────────────────────────────────────────────────────────────────────────┐
   * │                                                                                         │
   * │          Successfully registered Broker with the Ϟ Sparkswap Relayer!                   │
   * │                                                                                         │
   * │ Go to https://sparkswap.com/register/BAfwIYxkUqHJ3pLLh60AAQj3 to complete registration. │
   * │                                                                                         │
   * └─────────────────────────────────────────────────────────────────────────────────────────┘
   * ```
   */
  rpc Register (google.protobuf.Empty) returns (RegisterResponse);
}

/**
 * The time restriction for an order given by the user to the Broker.
 * It is important to note that this time in force only controls the Broker's actions and does not correspond to a time-in-force on the underlying network.
 */
enum TimeInForce {
  GTC = 0; // Good-til-cancelled, an order that remains in force until cancelled by the user
  FOK = 1; // Fill-or-kill, an order that can be completely filled or will not be executed
  IOC = 2; // Immediate-or-cancel, an order that will have as much filled immediately as possible with the remainder cancelled
}

/**
 * Parameters to create a block order on the Broker.
 */
message CreateBlockOrderRequest {
  // The market to place the block order in, e.g. `'BTC/LTC'`. Markets are always expressed as the combination of two common symbols, separated by a `/`.
  string market = 1;
  // Side of the market that the user wishes to take.
  Side side = 2;
  // Amount, in common units for a currency (e.g. bitcoins for BTC) that is the size of the order. This field supports decimal representation of units but uses a string since protobuf lacks a decimal type (e.g. `'0.16'`)
  string amount = 3;
  oneof price_restriction {
    // Whether this order should be executed as a market order, i.e. at the best available price in the market. It is important to note that there is no concept of a Market Order in the underlying network. Instead, the Broker will simulate Market Order behavior by filling all orders in the market until the order is completely filled.
    bool is_market_order = 4;
    // Price at which this order should executed, represented as a decimal string due to lack of Protobuf decimal support (e.g. `'1.05'`).
    string limit_price = 5;
  }

  // Time restriction for this block order.
  TimeInForce time_in_force = 6;
}

/**
 * Response from the broker after creating a block order.
 */
message CreateBlockOrderResponse {
  // The unique ID of the block order assigned by the broker. This is used to retrieve information about the order and to cancel it.
  string block_order_id = 1;
}

/**
 * An order on the SparkSwap Relayer.
 */
message Order {

  /**
   * Status of an order on the SparkSwap Relayer.
   */
  enum OrderStatus {
    // The order has been created on the Relayer.
    CREATED = 0;
    // The order has been placed and communicated to other marker participants.
    PLACED = 1;
    // The swap is being executed on the Payment Channel Networks
    EXECUTING = 3;
    // The swap preimage has been returned to the Relayer.
    COMPLETED = 4;
    // The order has encountered a failure.
    REJECTED = 5;
    // The order has been cancelled by the user.
    CANCELLED = 6;
  }

  // Unique ID assigned by the Relayer for this order.
  string order_id = 1;
  // Status of the order on the Relayer.
  OrderStatus order_status = 2;
  // Amount of the order expressed in a decimal string of common units for a currency (e.g. bitcoins for BTC).
  string amount = 3;
  // Price at which the order was placed, expressed as a decimal string ratio between the common units of the currencies (e.g. litecoins to bitcoins, not litoshis to satoshis). All orders on the SparkSwap Relayer have prices.
  string price = 4;
  // Any error messages related to the status of a REJECTED or FAILED order
  string order_error = 6;
}

/**
 * A fill of an order on the SparkSwap Relayer.
 */
message Fill {

  /**
   * Status of the fill on the SparkSwap Relayer.
   */
  enum FillStatus {
    // The fill has been created on the Relayer.
    CREATED = 0;
    // The fill has been accepted as the fill for the given order.
    FILLED = 1;
    // The swap has been executed on the Payment Channel Networks.
    EXECUTED = 2;
    // The preimage has been returned to the Relayer by the Maker.
    COMPLETED = 3;
    // The fill has encountered a failure.
    REJECTED = 4;
    // The fill has been cancelled.
    CANCELLED = 5;
  }
  // The Relayer-assigned unique ID of the order that this fill is for.
  string order_id = 1;
  // The Relayer-assignded unique ID for this fill.
  string fill_id = 2;
  // Status of the fill on the Relayer.
  FillStatus fill_status = 3;
  // Amount of the order to fill, expressed in a decimal string of common units for a currency (e.g. bitcoins for BTC). This can be any amount greater than zero and less than or equal to the amount in the order.
  string amount = 4;
  // Price at which the order was placed, expressed as a decimal string ratio between the common units of the currencies (e.g. litecoins to bitcoins, not litoshis to satoshis). All orders on the SparkSwap Relayer have prices.
  string price = 5;
  // Any error messages related to the status of a REJECTED or FAILED fill
  string fill_error = 6;
}

/**
 * An order placed by a user on a Broker.
 * These are called Block Orders because they are for (relatively) large blocks that get broken up into individual Orders and Fills on the Relayer.
 */
message BlockOrder {

  /**
   * Status of the block order on the Broker.
   */
  enum BlockOrderStatus {
    // The block order is still being worked by the Broker.
    ACTIVE = 0;
    // The block order was cancelled by the user.
    CANCELLED = 1;
    // The block order has successfully completed execution.
    COMPLETED = 2;
    // The block order has failed at some point and is no longer attempting execution.
    FAILED = 3;
  }

  // The unique ID for the block order assigned by the Broker.
  string block_order_id = 1;
  // The market that the block order is for, e.g. `'BTC/LTC'`. Markets are always expressed as the combination of two common symbols, separated by a `/`.
  string market = 2;
  // The side of the market that the block order is taking.
  Side side = 3;
  // Amount, in common units for a currency (e.g. bitcoins for BTC) that is the size of the order. This field supports decimal representation of units but uses a string since protobuf lacks a decimal type (e.g. `'0.16'`)
  string amount = 4;
  oneof price_restriction {
    // Whether this block order is/was executed as a market order, i.e. at the best available price in the market. It is important to note that there is no concept of a Market Order in the underlying network. Instead, the Broker will simulate Market Order behavior by filling all orders in the market until the order is completely filled.
    bool is_market_order = 13;
    // Price at which this order should executed, represented as a decimal string due to lack of Protobuf decimal support (e.g. `'1.05'`).
    string limit_price = 14;
  }

  // Time restriction for this block order.
  TimeInForce time_in_force = 5;
  // Current status of the block order.
  BlockOrderStatus status = 6;
  // BlockOrder creation unix timestamp in nanoseconds
  string timestamp = 7;
  // BlockOrder creation ISO8601 datetime in nanoseconds
  string datetime = 8;
}

/**
 * Parameters to retrieve a previously placed block order.
 */
message GetBlockOrderRequest {
  // ID for the block order assigned by the Broker.
  string block_order_id = 1;
}

/**
 * Representation of a retrieved block order.
 */
message GetBlockOrderResponse {
  // Status of the block order.
  BlockOrder.BlockOrderStatus status = 1;

  // The market that the block order is for, e.g. `'BTC/LTC'`. Markets are always expressed as the combination of two common symbols, separated by a `/`.
  string market = 10;
  // The side of the market that the block order is taking.
  Side side = 11;
  // Amount, in common units for a currency (e.g. bitcoins for BTC) that is the size of the order. This field supports decimal representation of units but uses a string since protobuf lacks a decimal type (e.g. `'0.16'`)
  string amount = 12;
  oneof price_restriction {
    // Whether this block order is/was executed as a market order, i.e. at the best available price in the market. It is important to note that there is no concept of a Market Order in the underlying network. Instead, the Broker will simulate Market Order behavior by filling all orders in the market until the order is completely filled.
    bool is_market_order = 13;
    // Price at which this order should executed, represented as a decimal string due to lack of Protobuf decimal support (e.g. `'1.05'`).
    string limit_price = 14;
  }
  // Time restriction for this block order.
  TimeInForce time_in_force = 15;
  // BlockOrder creation unix timestamp in nanoseconds
  string timestamp = 16;
  // BlockOrder creation ISO8601 datetime in nanoseconds
  string datetime = 17;

  // Amount of the block order that has been filled, in common units for a currency (e.g. bitcoins for BTC) represented as a decimal string (e.g. `'0.10'`)
  string fill_amount = 20;
  // All orders on the SparkSwap Relayer that were placed by the Broker in support of this block order.
  repeated Order orders = 21;
  // All fills of orders on the SparkSwap Relayer that were undertaken by the Broker in support of this block order.
  repeated Fill fills = 22;
}


/**
 * Request to cancel a previously created block order.
 */
message CancelBlockOrderRequest {
  // Unique ID for the block order as assigned by the Broker.
  string block_order_id = 1;
}

/**
 * Request to cancel all active block orders on the given market
 */
message CancelAllBlockOrdersRequest {
  // Market for which to cancel block orders, expressed as a string separating two common symbols with a '/', e.g. `'BTC/LTC'`
  string market = 1;
}

/**
 * Response from cancelling all active orders on a market
 */
message CancelAllBlockOrdersResponse {
  // Block order ids of block orders that were successfully cancelled
  repeated string cancelled_orders = 1;
  // Block order ids of block orders that were not successfully cancelled
  repeated string failed_to_cancel_orders = 2;
}

/**
 * All block orders in a given market.
 */
message GetBlockOrdersResponse {
  // A list of all block orders in the market.
  repeated BlockOrder block_orders = 1;
}

/**
 * Request to retrieve all block orders in a given market.
 */
message GetBlockOrdersRequest {
  // Market for which to retrieve block orders, expressed as a string separating two common symbols with a '/', e.g. `'BTC/LTC'`
  string market = 1;
}

/**
 * The OrderService manages all trading activity on the Broker.
 * It is the primary way that users interact with the Broker on a day-to-day basis.
 *
 * The OrderService deals primarily with block orders, which are instructions given to the Broker by the end-user and are executed by the Broker on the SparkSwap Network.
 * Brokers "work" block orders by breaking them into individual actions on the SparkSwap Relayer, namely placing limit orders and filling other participants' limit orders.
 * This separation between block orders worked by the Broker and the underlying orders on the SparkSwap Relayer allows users to get access to the features of orders they are accustomed to (e.g. market orders) without placing additional trust in the Relayer or exposing themselves to front-running.
 *
 * ```javascript
 * const address = 'localhost:27492'
 * const orderService = new brokerProto.OrderService(address, grpc.credentials.createInsecure())
 * ```
 */
service OrderService {
  /**
   * CreateBlockOrder creates new block orders on the Broker. This is the only way to initiate a trade on the broker.
   * Creating a block order returns a block order ID immediately, but that is not necessarily an indication that the block order has been successfully executed.
   * The user should check on the block order's status after it is created to understand if it has been completed.
   *
   * > Placing a market order:
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderService.createBlockOrder(
   *   {
   *     market: 'BTC/LTC', // trading BTC and LTC
   *     side: 'BID', // Place a buy order
   *     amount: '0.0001', // 0.0001 BTC being traded
   *     isMarketOrder: true, // use the best available price
   *     timeInForce: 'GTC' // execute this order until I cancel it
   *   },
   *   { deadline },
   *   (err, { blockOrderId }) => {
   *     if (err) return console.error(err)
   *     console.log({ blockOrderId })
   *   }
   * )
   * ```
   *
   * ```shell
   * > sparkswap buy 0.0001 --market BTC/LTC
   * ```
   *
   * > The above command will create a market block order on the Broker and will print:
   *
   * ```javascript
   * { "blockOrderId": "vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX" }
   * ```
   *
   * ```shell
   * { blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }
   * ```
   *
   * > Placing a limit order:
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderService.createBlockOrder(
   *   {
   *     market: 'BTC/LTC', // trading BTC and LTC
   *     side: 'BID', // Place a buy order
   *     amount: '0.0001', // 0.0001 BTC being traded
   *     limitPrice: '1.1', // at a price no worse than 1.1 LTC per BTC
   *     timeInForce: 'GTC' // execute this order until I cancel it
   *   },
   *   { deadline },
   *   (err, { blockOrderId }) => {
   *     if (err) return console.error(err)
   *     console.log({ blockOrderId })
   *   }
   * )
   * ```
   *
   * ```shell
   * > sparkswap buy 0.0001 1.1 --market BTC/LTC
   * ```
   *
   * > The above command will create a limit block order on the Broker and will print:
   *
   * ```javascript
   * { "blockOrderId": "o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs" }
   * ```
   *
   * ```shell
   * { blockOrderId: 'o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs' }
   * ```
   *
   */
  rpc CreateBlockOrder (CreateBlockOrderRequest) returns (CreateBlockOrderResponse) {
    option (.google.api.http) = {
      post: "/v1/orders"
      body: "*"
    };
  }
  /**
   * GetBlockOrder returns information on a previously placed block order. It should be used to check on the status of placed block orders.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * const blockOrder = orderService.getBlockOrder({ blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }, { deadline }, (err, blockOrder) => {
   *   if (err) return console.error(err)
   *   console.log(blockOrder)
   * })
   * ```
   *
   * ```shell
   * > sparkswap order status vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX
   * ```
   *
   * > The above command will retrieve the block order on the Broker and will print:
   *
   * ```javascript
   * {
   *   "status": "",
   *   "market": "BTC/LTC",
   *   "side": "BID",
   *   "amount": "0.0001",
   *   "isMarketOrder": true,
   *   "timeInForce": "GTC",
   *   "timestamp": "1538676318030164300",
   *   "datetime": "2018-09-21T10:40:31.8342339Z",
   *   "orders": [],
   *   "fills": []
   * }
   * ```
   *
   * ```shell
   * { price_restriction: 'isMarketOrder',
   *   status: 'ACTIVE',
   *   market: 'BTC/LTC',
   *   side: 'BID',
   *   amount: '0.0001000000000000',
   *   isMarketOrder: true,
   *   limitPrice: '',
   *   timeInForce: 'GTC',
   *   timestamp: '1538676318030164300',
   *   datetime: '2018-09-21T10:40:31.8342339Z',
   *   fillAmount: '',
   *   orders: [],
   *   fills: [] }
   * ```
   */
  rpc GetBlockOrder (GetBlockOrderRequest) returns (GetBlockOrderResponse) {
    option (.google.api.http) = {
      get: "/v1/orders/{block_order_id}"
    };
  }
  /**
   * CancelBlockOrder cancels a previously placed block order.
   * If the block order is already completed, or consists only of orders that are already being filled (either by this Broker or a counterparty), this will have no effect, as the Broker is bound to complete those orders or else lose their deposit.
   * If the block order is partially executed, the cancel will affect only future actions, the Broker will not attempt to roll back trades that have already been made.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderService.getBlockOrder({ blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }, { deadline }, (err) => {
   *   if (err) return console.error(err)
   * })
   * ```
   *
   * ```shell
   * > sparkswap order cancel vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX
   * ```
   *
   * > The above command will cancel the block order, but has no output.
   */
  rpc CancelBlockOrder (CancelBlockOrderRequest) returns (google.protobuf.Empty) {
    option (.google.api.http) = {
      delete: "/v1/orders/{block_order_id}"
      body: "*"
    };
  }
  /**
   * CancelAllBlockOrders cancels all active block orders on a market.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderService.cancelAllBlockOrders({ market: 'BTC/LTC' }, { deadline }, (err) => {
   *   if (err) return console.error(err)
   * })
   * ```
   *
   * ```shell
   * > sparkswap order cancel-all --market btc/ltc
   * ```
   *
   * ```javascript
   * { "cancelledOrders": [
   *     "XH3CBeemcGrVBKpc",
   *     "XH3CA12_5Ynujq8m",
   *     "XH3B-6hZjRstgjsz",
   *   ],
   *  "failedToCancelOrders": [
   *     "XH3CBODrC7PU3JY7"
   *   ]
   * }
   * ```
   *
   * ```shell
   * Successfully cancelled 4 orders on BTC/LTC market.
   * ```
   */
  rpc CancelAllBlockOrders (CancelAllBlockOrdersRequest) returns (CancelAllBlockOrdersResponse);
  /**
   * GetBlockOrders returns information on all of the block orders placed in a single market, like `BTC/LTC`.
   * It does not include complete information, such as the underlying orders and fills on the SparkSwap Relayer, or the amount of the order that has been filled. For that, use [GetBlockOrder](#getblockorder).
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderService.getBlockOrders({ market: 'BTC/LTC' }, { deadline }, (err, { blockOrders }) => {
   *   if (err) return console.error(err)
   *   console.log(blockOrders)
   * })
   * ```
   *
   * ```shell
   * > sparkswap order summary --market BTC/LTC
   * ```
   *
   * > The above command will retrieve the block orders on the Broker and will print:
   *
   * ```javascript
   * [
       {
          price_restriction: 'limitPrice',
          blockOrderId: 'XLEdhQqW_vQfJ1xW',
          market: 'BTC/LTC',
          side: 'BID',
          amount: '0.0001000000000000',
          isMarketOrder: false,
          limitPrice: '60.0000000000000000',
          timeInForce: 'GTC',
          status: 'ACTIVE',
          timestamp: '1555111302274449400',
          datetime: '2019-04-12T23:21:42.2744494Z'
        },
        {
          price_restriction: 'isMarketOrder',
          blockOrderId: 'XLEeQPNXsyJ3_MsV',
          market: 'BTC/LTC',
          side: 'BID',
          amount: '0.0001000000000000',
          isMarketOrder: true,
          limitPrice: '',
          timeInForce: 'GTC',
          status: 'ACTIVE',
          timestamp: '1555111488621020800',
          datetime: '2019-04-12T23:24:48.6210208Z'
        }
   * ]
   * ```
   *
   * ```shell
   * Orders: BTC/LTC
   *
   * ┌────────────────────┬──────────┬──────────┬───────────────┬────────────────┬──────────┬──────────────────────────┐
   * │ Order ID           │ Status   │ Side     │ Amount        │ Limit Price    │ Time     │ Created At               │
   * ├────────────────────┼──────────┼──────────┼───────────────┼────────────────┼──────────┼──────────────────────────┤
   * │ XLEdhQqW_vQfJ1xW   │ ACTIVE   │ BID      │ 0.00010000000 │ 60.00000000000 │ GTC      │ 2019-04-12T23:21:42.274Z │
   * ├────────────────────┼──────────┼──────────┼───────────────┼────────────────┼──────────┼──────────────────────────┤
   * │ XLEeQPNXsyJ3_MsV   │ ACTIVE   │ BID      │ 0.00010000000 │ 60.00000000000 │ GTC      │ 2019-04-12T23:24:48.621Z │
   * └────────────────────┴──────────┴──────────┴───────────────┴────────────────┴──────────┴──────────────────────────┘
   * ```
   */
  rpc GetBlockOrders (GetBlockOrdersRequest) returns (GetBlockOrdersResponse) {
    option (.google.api.http) = {
      get: "/v1/orders"
    };
  }
}

/**
 * Request for updates in a given market.
 */
message WatchMarketRequest {
  // Market to retrieve updates for, e.g. `'BTC/LTC'`.
  string market = 1;
}

/**
 * An update to the watched market.
 */
message WatchMarketResponse {

  // Type of event this update is.
  EventType type = 1;
  // The market update
  MarketEvent market_event = 2;

  /**
   * Types of events, used to distinguish between adding orders to a market and removing them.
   */
  enum EventType {
      // Add an event to a market, typically due to an order being placed.
      ADD = 0;
      // Remove an event from the market, typically due to an order being cancelled or filled.
      DELETE = 1;
  }
}

/**
 * Market events are events that change the orderbook for a given market. The are a combination of orders, fills, and cancels.
 */
message MarketEvent {
  // The Relayer-assigned ID of the underlying order
  string order_id = 1;
  // Amount of the order expressed in a decimal string of common units for a currency (e.g. bitcoins for BTC).
  string amount = 2;
  // Price at which the order was placed, expressed as a decimal string ratio between the common units of the currencies (e.g. litecoins to bitcoins, not litoshis to satoshis). All orders on the SparkSwap Relayer have prices.
  string price = 3;
  // Side that the order is taking
  Side side = 4;
}

message GetOrderbookRequest {
  // Market to retrieve updates for, e.g. `'BTC/LTC'`.
  string market = 1;
  // Number to limit results of either side of orderbook
  int64 limit_per_side = 2;
}

message Bid {
  // price of the bid
  string price = 1;
  // amount to be bought
  string amount = 2;
}

message Ask {
  // price of the ask
  string price = 1;
  // amount to be sold
  string amount = 2;
}

/**
 * Contains information about bids and asks on the orderbook
 */
message GetOrderbookResponse {
  // list of bids on the orderbook in the current state
  repeated Bid bids = 1;
  // list of asks on the orderbook in the current state
  repeated Ask asks = 2;
  // time in milliseconds of generation time of the orderbook (when the call was made)
  int64 timestamp = 3;
  // time the last entry that was added (ISO8601 datetime string)
  string datetime = 4;
}


/**
 * Supported markets expose all relevant information about a market that is supported by sparkswap
 */
message SupportedMarket {
  // unique id for the market
  string id = 1;
  // symbol of the market. e.g. `BTC/LTC`
  string symbol = 2;
  // symbol of base currency
  string base = 3;
  // symbol of counter currency
  string counter = 4;
  // if the market is active or not
  bool active = 5;
}

/**
 * Contains information about all supported markets on sparkswap
 */
message GetSupportedMarketsResponse {
  // a list of all supported markets on sparkswap
  repeated SupportedMarket supported_markets = 1;
}

message GetMarketStatsRequest {
  // Market to commit the amount in currency to. e.g. `BTC/LTC`
  string market = 1;
}

message GetMarketStatsResponse {
  // symbol of the market. e.g. `BTC/LTC`
  string symbol = 1;

  // 64-bit Unix nano-second timestamp
  int64 timestamp = 2;

  // ISO8601 datetime string (nano-seconds)
  string datetime = 3;

  // NOTE:
  // The following parameters are all float-value strings
  //

  // highest price in past 24 hours
  string high = 4;

  // lowest price in past 24 hours
  string low = 5;

  // current best bid
  string bid = 6;

  // current best bid's amount
  string bidVolume = 7;

  // current best ask
  string ask = 8;

  // current best ask's amount
  string askVolume = 9;

  // volume weighed average price (vwap) for the past 24 hours
  string vwap = 10;

  // volume of base currency in past 24 hours
  string baseVolume = 11;

  // volume of counter (quote) currency in past 24 hours
  string counterVolume = 12;
}

/**
 * Parameters to retrieve a list of trades within a specified time frame on a given market
 */
message GetTradesRequest {
  // Market to retrieve updates for, e.g. `'BTC/LTC'`.
  string market = 1;
  // Starting date for the results. ISO8601
  string since = 2;
  // int64 number to limit results
  int64 limit = 3;
}

/**
 * Trade exposes all relevant information about a filled order
 */
message Trade {
  // id of the trade
  string id = 1;
  // Trade creation unix timestamp in nanoseconds
  string timestamp = 2;
  // Trade creation ISO8601 datetime in nanoseconds
  string datetime = 3;
  // order id
  string order = 4;
  // market name the trade was executed on e.g. BTC/LTC
  string market = 5;
  // order type, 'market', 'limit' or undefined/None/null
  string type = 6;
  // direction of the trade, 'buy' or 'sell'
  string side = 7;
  // float price in quote currency
  string price = 8;
  // amount of base currency
  string amount = 9;
}

/**
 * Contains information about all trades on sparkswap
 */
message GetTradesResponse {
  repeated Trade trades = 1;
}

/**
 * The OrderBookService is intended to update users on network activity and provide an up to date orderbook for the user.
 *
 * It is the counterpoint to the [OrderService](#orderservice) in that it is read-only and deals with the wider network,
 * never touching the Block Orders that the user creates and cancels.
 *
 * ```javascript
 * const address = 'localhost:27492'
 * const orderBookService = new brokerProto.OrderBookService(address, grpc.credentials.createInsecure())
 * ```
 */
service OrderBookService {
  /**
   * WatchMarket opens a stream from the Broker with updates as to the current state of the orderbook.
   * Those updates come in the form of `ADD`s and `DELETE`s, so by updating a UI with those changes, the user can see the current state of the orderbook.
   * > Below is a simple example of a console-based UI for an orderbook:
   *
   * ```javascript
   * const call = orderBookService.watchMarket(request)
   * const orders = new Map()
   * call.on('data', (update) => {
   *   const { orderId, side, price, amount } = update.marketEvent
   *   const { type } = update
   *   if (type === EVENT_TYPES.DELETE) {
   *     orders.delete(orderId)
   *   } else {
   *     orders.set(orderId, { price, amount })
   *   }
   *   console.clear()
   *   console.log(Array.from(orders.values()).sort(function (a, b) { return parseFloat(a) - parseFloat(b) }))
   * })
   * ```
   *
   * ```shell
   * > sparkswap orderbook --market BTC/LTC
   * ```
   *
   * > After an update, the UI would show something like this:
   *
   * ```javascript
   * [
   *   {
   *     "side": "ASK",
   *     "price": "1.1",
   *     "amount": "0.0001"
   *   },
   *   {
   *     "side": "ASK",
   *     "price": "1.0",
   *     "amount": "0.0001"
   *   }
   * ]
   * ```
   *
   * ```shell
   * Market: BTC/LTC                                                                                                                            Ϟ SparkSwap Broker
   *                                                                                                                                           v0.2.0-alpha-preview
   *                                                                                                                                           http://sparkswap.com
   *
   * ┌──────────────────────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────┐
   * │ ASKS                                                                         │ BIDS                                                                         │
   * ├──────────────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤
   * │  Price                                Depth (BTC)                            │  Price                                Depth (BTC)                            │
   * │                                                                              │   1.2970000000000000                   0.0001000000000000                    │
   * │                                                                              │   1.2970000000000000                   0.0001000000000000                    │
   * │                                                                              │   1.1930000000000000                   0.0001000000000000                    │
   * │                                                                              │   1.1790000000000000                   0.0001300000000000                    │
   * │                                                                              │   1.1680000000000000                   0.0002000000000000                    │
   * │                                                                              │   1.1000000000000000                   0.0002000000000000                    │
   * └──────────────────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────┘
   *
   * ```
   */
  rpc WatchMarket (WatchMarketRequest) returns (stream WatchMarketResponse);
  /**
   * GetOrderbook returns price and amount information about the bids and asks on the orderbook in the current state.
   *
   * When GetOrderbookRequest includes a limit parameter, the total number of bids will not exceed the limit and the
   * total number of asks will not exceed the limit.
   *
   * > Below is a simple example of a console-based UI for an orderbook:
   *
   * ```javascript
   * const { bids, asks, timestamp, datetime } = orderBookService.getOrderbook(request)
   * console.log({ bids, asks, timestamp, datetime })
   * ```
   *
   *
   * > The response from the above call would look like:
   *
   * ```javascript
   * { bids:
   *    [ { price: '0.0003000000000000', amount: '0.0000100000000000' },
   *      { price: '0.0002000000000000', amount: '0.0000100000000000' } ],
   *   asks:
   *    [ { price: '0.0003000000000000', amount: '0.0000300000000000' } ],
   *   timestamp: '1537466254497',
   *   datetime: '2018-09-20T16:27:28.0733219Z' }
   * ```
   */
  rpc GetOrderbook (GetOrderbookRequest) returns (GetOrderbookResponse) {
    option (.google.api.http) = {
      get: "/v1/orderbook"
    };
  }
  /**
   * getSupportedMarkets returns detailed information about markets currently supported on sparkswap.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderbookService.getSupportedMarkets({}, { deadline }, (err, { supportedMarkets }) => {
   *   if (err) return console.error(err)
   *   console.log({ supportedMarkets })
   * })
   * ```
   *
   * ```shell
   * > sparkswap market supported-markets
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * {
   *   "supportedMarkets": [
   *     {
   *       "id": "BTC/LTC",
   *       "symbol": "BTC/LTC",
   *       "base": "BTC",
   *       "counter": "LTC",
   *       "active": true,
   *     }
   *   ]
   * }
   * ```
   *
   * ```shell
   * { supportedMarkets:
   *   [ { id: 'BTC/LTC',
   *       symbol: 'BTC/LTC',
   *       base: 'BTC',
   *       counter: 'LTC',
   *       active: true } ] }
   * ```
   */
  rpc getSupportedMarkets (google.protobuf.Empty) returns (GetSupportedMarketsResponse) {
    option (.google.api.http) = {
      get: "/v1/markets"
    };
  }
   /**
   * getMarketStats returns statistics (price ticker information) for a particular market/symbol for a period of the last 24 hours
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * const market = "BTC/LTC"
   * orderbookService.getMarketStats({ market }, { deadline }, (err, res) => {
   *   if (err) return console.error(err)
   *   console.log(res)
   * })
   * ```
   *
   * ```shell
   * > sparkswap market market-stats --market BTC/LTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * {
   *   "symbol": "BTC/LTC",
   *   "timestamp": "1537386049351518282",
   *   "datetime": "2018-09-19T19:40:49.350111174Z",
   *   "high": "59.313",
   *   "low": "59.212",
   *   "bid": "0.0001",
   *   "bidVolume": "59.311",
   *   "ask": "0.0001",
   *   "askVolume": "59.32",
   *   "vwap": "59.324",
   *   "baseVolume": "20.1233",
   *   "counterVolume": "1207.398"
   * }
   * ```
   *
   * ```shell
   * { "symbol": "BTC/LTC",
   *   "timestamp": "1537386049351518282",
   *   "datetime": "2018-09-19T19:40:49.350111174Z",
   *   "high": "59.313",
   *   "low": "59.212",
   *   "bid": "0.0001",
   *   "bidVolume": "59.311",
   *   "ask": "0.0001",
   *   "askVolume": "59.32",
   *   "vwap": "59.324",
   *   "baseVolume": "20.1233",
   *   "counterVolume": "1207.398" }
   * ```
   */
  rpc getMarketStats (GetMarketStatsRequest) returns (GetMarketStatsResponse) {
    option (.google.api.http) = {
      get: "/v1/market_stats"
    };
  }
  /**
   * getTrades returns detailed information about trades from a given time range.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderbookService.getTrades(
   *   {
   *     market: 'BTC/LTC', // trading BTC and LTC
   *     since: '2018-09-20T18:58:07.866Z', // only retrieve records since this date
   *     limit: 10, // retrieve first 10 records
   *   }, { deadline }, (err, { trades }) => {
   *   if (err) return console.error(err)
   *   console.log({ trades })
   * }))
   * ```
   *
   * ```shell
   * > sparkswap market trades 2018-09-20T18:58:07.866Z 50 --market BTC/LTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * { trades:
   *  [ { id: 'yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm',
   *    timestamp: '1537526431834',
   *    datetime: '2018-09-21T10:40:31.034Z',
   *    order: 'tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg',
   *    market: 'BTC/LTC',
   *    type: 'limit',
   *    side: 'buy',
   *    price: '0.0010000000000000',
   *    amount: '400.000000000000',
   *    info: '{"id":"yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm","timestamp":"1537526431834","datetime":"2018-09-21T10:40:31.034Z","order":"tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg","symbol":"BTC/LTC","type":"limit","side":"buy","price":"0.0010000000000000","amount":"400.000000000000"}' },
   *   { id: 'd4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP',
   *    timestamp: '1537527538513',
   *    datetime: '2018-09-21T10:58:58.513Z',
   *    order: 'W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt',
   *    market: 'BTC/LTC',
   *    type: 'limit',
   *    side: 'sell',
   *    price: '0.1000000000000000',
   *    amount: '50.000000000000000',
   *    info: '{"id":"d4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP","timestamp":"1537527538513","datetime":"2018-09-21T10:58:58.513Z","order":"W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt","symbol":"BTC/LTC","type":"limit","side":"sell","price":"0.1000000000000000","amount":"50.000000000000000"}' } ] }
   * ```
   *
   * ```shell
   * { trades:
   *  [ { id: 'yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm',
   *    timestamp: '1537526431834',
   *    datetime: '2018-09-21T10:40:31.034Z',
   *    order: 'tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg',
   *    market: 'BTC/LTC',
   *    type: 'limit',
   *    side: 'buy',
   *    price: '0.0010000000000000',
   *    amount: '400.000000000000',
   *    info: '{"id":"yK2LMkgQPZRk1riK9pgwIyVjr7xMFOgn0iCF6FPm","timestamp":"1537526431834","datetime":"2018-09-21T10:40:31.034Z","order":"tgjXZ6Mr_xcRzjMZ4xUkNnUpHL7OuJvBbFGG-CTg","symbol":"BTC/LTC","type":"limit","side":"buy","price":"0.0010000000000000","amount":"400.000000000000"}' },
   *   { id: 'd4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP',
   *    timestamp: '1537527538513',
   *    datetime: '2018-09-21T10:58:58.513Z',
   *    order: 'W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt',
   *    market: 'BTC/LTC',
   *    type: 'limit',
   *    side: 'sell',
   *    price: '0.1000000000000000',
   *    amount: '50.000000000000000',
   *    info: '{"id":"d4OlWlhKEe3D9-UmrwfpM7T0_2bd7t8BI4tZCuKP","timestamp":"1537527538513","datetime":"2018-09-21T10:58:58.513Z","order":"W36W9r-krFzjv4L6CwOM1hoPthAd7tlqzSBHUKDt","symbol":"BTC/LTC","type":"limit","side":"sell","price":"0.1000000000000000","amount":"50.000000000000000"}' } ] }
   * ```
   */
  rpc GetTrades (GetTradesRequest) returns (GetTradesResponse) {
    option (.google.api.http) = {
      get: "/v1/trades"
    };
  }
}

/**
 * Symbol is the common representation of a given currency.
 */
enum Symbol {
  // Bitcoin
  BTC = 0;
  // Litecoin
  LTC = 1;
}

/**
 * Request for a new address to send funds to for a given currency.
 */
message NewDepositAddressRequest {
  // Currency for which to generate the address
  Symbol symbol = 1;
}

/**
 * Created deposit address for a given currency.
 */
message NewDepositAddressResponse {
  // Address created.
  string address = 1;
}

/**
 * Balance in a currency in terms of what is committed in channels and total balance in wallets managed by this node.
 */
message Balance {
  // Currency of the balance.
  string symbol = 1;
  // Total balance of the wallets managed by this node in this currency, including balance in channels. This is currently in common units (e.g. 0.5 BTC)
  string uncommitted_balance = 2;
  // Balance in the listed currency that is currently in channels. This is currently in common units (e.g. 0.5 BTC)
  string total_channel_balance = 3;
  // Balance in the listed currency that is currently in pending channels. This is currently in common units (e.g. 0.5 BTC)
  string total_pending_channel_balance = 4;
  // Balance in the listed currency that is currently in pending closing channels and unconfirmed wallet balance. This is currently in common units (e.g. 0.5 BTC)
  string uncommitted_pending_balance = 5;
  // Total balance across all channels that are reserved (reasons may include fees reserved on the underlying network). This is currently in common units (e.g. 0.5 BTC)
  string total_reserved_channel_balance = 6;
  // Error message if balances are not available
  string error = 10;
}

/**
 * All balances for a Broker.
 */
message GetBalancesResponse {
  // Balances in all currencies available to this Broker.
  repeated Balance balances = 1;
}

/**
 * Local and remote balances in the listed currency in the active, pending and inactive channels.
 */
message Capacity {
  // Currency of the balance.
  string symbol = 1;
  // Total pending amount a user can send in the currency. This is currently in common units (e.g. 0.15 BTC)
  string pending_send_capacity = 4;
  // Total pending amount a user can receive in the currency. This is currently in common units (e.g. 0.15 BTC)
  string pending_receive_capacity = 5;
  // Total inactive amount a user can send in the currency. This is currently in common units (e.g. 0.15 BTC)
  string inactive_send_capacity = 6;
  // Total inactive amount a user can send in the currency. This is currently in common units (e.g. 0.15 BTC)
  string inactive_receive_capacity = 7;
  // Total available amount a user can send in the currency. This is currently in common units (e.g. 0.15 BTC)
  string available_send_capacity = 8;
  // Total available amount a user can send in the currency. This is currently in common units (e.g. 0.15 BTC)
  string available_receive_capacity = 9;
  // Total inbound outstanding amount. This is currently in common units (e.g. 0.15 BTC)
  string outstanding_send_capacity = 10;
  // Total outbound outstanding amount. This is currently in common units (e.g. 0.15 BTC)
  string outstanding_receive_capacity = 11;
  // Status of capacities. OK for success or FAILED if an error occurred when requesting capacities
  string status = 20;
  // Error message if status is FAILED
  string error = 21;
}

/**
 * Trading capacities for the base and counter currencies for a given market.
 */
message GetTradingCapacitiesResponse {
  // local and remote capacities in active, pending and inactive channels for the base currency
  Capacity base_symbol_capacities = 1;
  // local and remote capacities in active, pending and inactive channels for the counter currency
  Capacity counter_symbol_capacities = 2;
}

/**
 * Request to retrieve local and remote capacities in active, pending and inactive channels for a given market
 */
message GetTradingCapacitiesRequest {
  // Name of the market to retrieve capacities for
  string market = 1;
}

/**
 * Request to commit an amount of a given currency on a given market.
 */
message CommitRequest {
  // Currency of the balance to commit.
  Symbol symbol = 1;
  // Amount of the currency to commit. This is currently in common units (e.g. 0.5 BTC)
  string balance = 2;
  // Market to commit the amount in currency to. e.g. BTC/LTC
  string market = 3;
}

/**
 * Request to close channels currently open on the given market
 */
message ReleaseChannelsRequest {
  // Market to close channels on
  string market = 1;
  // Force channels (active, inactive and pending) to close, which may result in funds being locked for additional time and fees
  bool force = 2;
}

/**
 * Container for channel information for a specific currency on a given market
 */
message ReleasedCurrency {
  // Currency of the information
  string symbol = 1;
  // Status of the channel. e.g. RELEASED or FAILED
  string status = 2;
  // Message that identifies an issue with a released channel. Only available if status of channel is not `RELEASED`
  string error = 10;
}

message ReleaseChannelsResponse {
  // Channel status information for the base currency
  ReleasedCurrency base = 1;
  // Channel status information for the counter currency
  ReleasedCurrency counter = 2;
}

/**
 * Get the payment channel network address for a given currency.
 */
message GetPaymentChannelNetworkAddressRequest {
  // Currency for which to retrieve the address
  Symbol symbol = 1;
}

/**
 * Created deposit address for a given currency.
 */
message GetPaymentChannelNetworkAddressResponse {
  // Network Address retrieved
  string payment_channel_network_address = 1;
}

/**
 * Request to withdraw funds from wallet to specified address
 */
message WithdrawFundsRequest {
  // Currency of funds to withdraw
  Symbol symbol = 1;
  // Amount of funds to withdraw
  string amount = 2;
  // Address to send the funds to
  string address = 3;
}

message WithdrawFundsResponse {
  // transaction id of the withdrawal
  string txid = 1;
}

/**
 * Request to create a wallet for a specific currency
 */
message CreateWalletRequest {
  // Currency of wallet
  string symbol = 1;
  // Password for the wallet
  string password = 2;
}

/**
 * CreateWallet response that contains wallet backup information.
 *
 * The returned array is a recovery seed that a broker can use to recover funds
 * from their crypto wallet in the cause of fatal error or loss of data.
 *
 * The information returned from this response should be kept private, as any user
 * could potentially use this info to steal your on-chain funds.
 *
 * When this information is returned, make sure to write it down and store it
 * in a safe place.
 */
message CreateWalletResponse {
  // 24 length Array of recovery seed words
  repeated string recovery_seed = 1;
}

/**
 * Request to unlock a wallet for a specific currency
 */
message UnlockWalletRequest {
  // Currency of wallet
  string symbol = 1;
  // Password for the wallet
  string password = 2;
}

/**
 * Get the wallet summary of a given currency
 */
message WalletHistoryRequest {
  // Currency of the wallet
  Symbol symbol = 1;
}

/**
 * WalletHistory response that contains transaction history for a specific wallet
 */
message WalletHistoryResponse {
  enum TransactionType {
    CHANNEL_CLOSE = 1;
    CHANNEL_OPEN = 2;
    DEPOSIT = 3;
    WITHDRAW = 4;
    UNKNOWN = 10;
  }

  message Transaction {
    // Type of transaction
    TransactionType type = 1;
    // The amount of the transaction (string float value)
    string amount = 2;
    // The transaction hash of a transaction
    string transaction_hash = 3;
    // Block height of the transaction
    int64 block_height = 4;
    // unix timestamp
    int64 timestamp = 5;
    // The amount of fees from the transaction (string float value)
    string fees = 6;
    // Specifies if the transaction is still pending a block confirmation
    bool pending = 7;
  }

  repeated Transaction transactions = 1;
}

/**
 * The WalletService is for interacting with the wallets managed by the Broker on behalf of the user.
 *
 * It is used primarily during set up (e.g. making deposits) of a Broker.
 *
 * ```javascript
 * const address = 'localhost:27492'
 * const walletService = new brokerProto.WalletService(address, grpc.credentials.createInsecure())
 * ```
 */
service WalletService {
  /**
   * NewDepositAddress generates a new address for the user to deposit currency into to be used for trading.
   * The address is managed by a wallet in an underlying Payment Channel Network node, and so should be considered a hot wallet.
   *
   * ```javascript
   * const address = await walletService.newDepositAddress({ symbol: 'BTC' })
   * console.log(address)
   * ```
   *
   * ```shell
   * > sparkswap wallet new-deposit-address BTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * > TODO
   * ```
   *
   * ```shell
   * sb1qsakedujs4exdq5dz2cpldcph6hlvf82l8mn8uk
   * ```
   */
  rpc NewDepositAddress (NewDepositAddressRequest) returns (NewDepositAddressResponse) {
    option (.google.api.http) = {
      post: "/v1/wallet/address"
      body: "*"
    };
  }
  /**
   * GetBalances retrieves the balance in all currency in wallets managed by Payment Channel Network nodes for this Broker.
   *
   * Balances are divided into `uncommittedBalance` (i.e. everything not in a channel), `totalChannelBalance` (i.e. everything in channels opened by the Payment Channel Network nodes),
   * `totalPendingChannelBalance` (i.e. funds in channels that have finished the funding workflow and are waiting for confirmations for the funding txn), `uncommittedPendingBalance`
   * (i.e funds in channels that are pending closure or unconfirmed unspent outputs under control of the wallet), and `totalReservedChannelBalance` (i.e. funds in a channel that aren't
   * available for the channel initiator to send).`
   *
   * NOTE: If an engine is unavailable, the balances for the particular engine will be empty `''`
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * walletService.getBalances({}, { deadline }, (err, { balances }) => {
   *   if (err) return console.error(err)
   *   console.log(balances)
   * })
   * ```
   *
   * ```shell
   * > sparkswap wallet balance
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * [
   *   {
   *     "symbol": "BTC",
   *     "uncommittedBalance": "10.0000000000000000",
   *     "totalChannelBalance": "0.1670000000000000",
   *     "totalPendingChannelBalance": "0.0001000000000000",
   *     "uncommittedPendingBalance": "0",
   *     "totalReservedChannelBalance": "0.0000905000000000"
   *   },
   *   {
   *     "symbol": "LTC",
   *     "uncommittedBalance": "10.0000000000000000",
   *     "totalChannelBalance": "0.1670000000000000",
   *     "totalPendingChannelBalance": "0.0002000000000000",
   *     "uncommittedPendingBalance": "0",
   *     "totalReservedChannelBalance": "0.0000905000000000"
   *   }
   * ]
   * ```
   *
   * ```shell
   * Wallet Balances
   * ┌──────────┬──────────────────────────────────┬──────────────────────────────────┐
   * │          │ Committed (Pending)              │ Uncommitted (Pending)            │
   * ├──────────┼──────────────────────────────────┼──────────────────────────────────┤
   * │ BTC      │ 0.1676816500000000 (0.00000000)  │ 9.8321513500000000 (0.00000000)  │
   * ├──────────┼──────────────────────────────────┼──────────────────────────────────┤
   * │ LTC      │ 0.0000000000000000 (0.00000000)  │ 10.0000000000000000 (0.00000000) │
   * └──────────┴──────────────────────────────────┴──────────────────────────────────┘
   * ```
   * ```shell
   * > sparkswap wallet balance --reserved
   * ```
   * Passing the optional `--reserved` flag will print
   * ```shell
   * ┌─────┬──────────────────────────────────────────────────────┬──────────────────────────────────┐
   * │     │ Committed (Pending) [Reserved]                       │ Uncommitted (Pending)            │
   * ├─────┼──────────────────────────────────────────────────────┼──────────────────────────────────┤
   * │ BTC │ 0.1676816500000000 (0.00000000) [0.0000905000000000] │ 0.8321399800000000 (0.00000000)  │
   * ├─────┼──────────────────────────────────────────────────────┼──────────────────────────────────┤
   * │ LTC │ 0.0000000000000000 (0.00000000) [0.0000000000000000] │ 10.0000000000000000 (0.00000000) │
   * └─────┴──────────────────────────────────────────────────────┴──────────────────────────────────┘
   * ```
   */
  rpc GetBalances (google.protobuf.Empty) returns (GetBalancesResponse) {
    option (.google.api.http) = {
      get: "/v1/wallet/balances"
    };
  }
  /**
   * Commit opens a channel with the Relayer with the given amount of currency on the Broker's side, and requests that the Relayer open a channel to the Broker with the inverse currency of equivalent amount on the Relayer's side.
   * This allows the Broker to trade in the market, since it has an outgoing channel and an incoming channel.
   *
   * The market parameter will determine the inverse currency, if you commit LTC to the BTC/LTC market, the Broker will request a BTC channel to be opened from the Relayer.
   *
   * Since the Network is in testing stages, rather than relying on the Network's exchange rate between BTC and LTC to determine how large of a channel to open, we use a set rate of 60 LTC to 1 BTC.
   * This also has the property of matching the conversion used in LND, so that when we run into things like the max channel size (in place while LND is in Beta), we can be consistent with LTC and BTC.
   *
   * > The below command has no output, but will throw an error if one is encountered.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * walletService.commit(
   *   {
   *     // We are committing LTC to a channel on the BTC/LTC market
   *     // the Broker will request a BTC channel be opened back to itself.
   *     symbol: 'LTC',
   *     // The amount to commit to the channel in common units (e.g. 0.016 BTC).
   *     // The Broker will request a BTC channel of size 0.0167 / 60 be opened back to itself.
   *     balance: '0.0167',
   *     market: 'BTC/LTC'
   *   },
   *   { deadline },
   *   (err) => {
   *     if (err) return console.error(err)
   *   }
   * )
   * ```
   *
   * ```shell
   * > sparkswap wallet commit LTC --market BTC/LTC
   * ```
   */
  rpc Commit (CommitRequest) returns (google.protobuf.Empty) {
    option (.google.api.http) = {
      post: "/v1/wallet/commit"
      body: "*"
    };
  }
  /**
   * ReleaseChannels closes all the channels on the given market.
   * If you pass in `BTC/LTC` as the market to releaseChannels, closeChannels will be called on both the BTC and LTC engines. If channels were closed,
   * there will an empty response unless an error is encountered.
   *
   * > The below command has no output, but will throw an error if one is encountered.
   *
   * ```javascript
   * walletService.releaseChannels( { market: 'BTC/LTC' }, (err) => {
   *   if (err) return console.error(err)
   * })
   * ```
   *
   * ```shell
   * > sparkswap wallet release --market BTC/LTC
   * ```
   *
   * > Additionally, you can pass a `force` flag which will force close channels on a specific market
   *
   * ```javascript
   * walletService.releaseChannels( { market: 'BTC/LTC', force: true }, (err) => {
   *   if (err) return console.error(err)
   * })
   * ```
   *
   * ```shell
   * > sparkswap wallet release --market BTC/LTC --force
   * ```
   *
   */
  rpc ReleaseChannels (ReleaseChannelsRequest) returns (ReleaseChannelsResponse) {
    option (.google.api.http) = {
      post: "/v1/wallet/release"
      body: "*"
    };
  }
  /**
   * GetPaymentChannelNetworkAddress retrieves the Payment Channel Network Address for the given currency.
   *
   * ```javascript
   * const { paymentChannelNetworkAddress } = await walletService.getPaymentChannelNetworkAddress({ symbol: 'BTC' })
   * console.log(paymentChannelNetworkAddress)
   * ```
   *
   * ```shell
   * > sparkswap wallet network-address BTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * > "025f08036e00e38468f52d68bb83939995440b72730bfaae99ace5630630997623@your.daemon:10113"
   * ```
   *
   * ```shell
   * 025f08036e00e38468f52d68bb83939995440b72730bfaae99ace5630630997623@your.daemon:10113
   * ```
   */
  rpc GetPaymentChannelNetworkAddress (GetPaymentChannelNetworkAddressRequest) returns (GetPaymentChannelNetworkAddressResponse);
  /**
   * GetTradingCapacities retrieves the remote and local capacities from the base and counter engines active, pending and inactive channels.
   *
   * Capacities are divided into three categories, active, pending and inactive. Each of these categories are further broken down into
   * the categories local and remote. For example, the activeSendCapacity is the local capacity in active channels for that engine, where pendingReceiveCapacity
   * is the remote capacity in pending channels for that engine. The response from GetTradingCapacities is a baseSymbolCapacities and counterSymbolCapacities
   * object where the respective capacities are grouped.
   *
   * ```javascript
   * walletService.getTradingCapacities({market: 'BTC/LTC}, (err, { baseSymbolCapacities, counterSymbolCapacities }) => {
   *   if (err) return console.error(err)
   *   console.log(baseSymbolCapacities)
   *   console.log(counterSymbolCapacities)
   * })
   * ```
   *
   * ```shell
   * > sparkswap wallet network-status --market BTC/LTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * { "symbol": "BTC",
   *   "activeSendCapacity": "0.16768165",
   *   "activeReceiveCapacity": "0.0027057",
   *   "pendingSendCapacity": "0",
   *   "pendingReceiveCapacity": "0",
   *   "inactiveSendCapacity": "0",
   *   "inactiveReceiveCapacity": "0"
   * },
   * { "symbol": "LTC",
   *   "activeSendCapacity": "0.16741015",
   *   "activeReceiveCapacity": "10.065967",
   *   "pendingSendCapacity": "0",
   *   "pendingReceiveCapacity": "0",
   *   "inactiveSendCapacity": "0",
   *   "inactiveReceiveCapacity": "0"
   * }
   * ```
   *
   * ```shell
   * BTC/LTC
   * ┌──────────────┬────────────────────────┬────────────────────────┐
   * │              │ BTC Capacity           │ LTC Capacity           │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │ Available    │                        │                        │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Buy BTC    │ 0.0000380000000000     │ 0.0000000000000000     │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Sell BTC   │ 0.1436436500000000     │ 10.0599490000000000    │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │ Outstanding  │                        │                        │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Buy BTC    │ 0.0027057000000000     │ 0.1674101500000000     │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Sell BTC   │ 0.1676816500000000     │ 10.0659670000000000    │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │ Pending      │                        │                        │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Buy BTC    │ 0.0000000000000000     │ 0.0000000000000000     │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Sell BTC   │ 0.0000000000000000     │ 0.0000000000000000     │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │ Inactive     │                        │                        │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Buy BTC    │ 0.0000000000000000     │ 0.0000000000000000     │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Sell BTC   │ 0.0000000000000000     │ 0.0000000000000000     │
   * └──────────────┴────────────────────────┴────────────────────────┘
   * ```
   */
  rpc GetTradingCapacities (GetTradingCapacitiesRequest) returns (GetTradingCapacitiesResponse);

  /**
   * WithdrawFunds moves funds (of the specified currency and amount) to the specified address
   *
   * ```javascript
   * const { txid } = await walletService.withdrawFunds({ symbol: 'BTC', amount: '2', address: 'asdfasdf' })
   * console.log(txid)
   * ```
   *
   * ```shell
   * > sparkswap wallet withdraw BTC 10 --wallet-address asdfadf
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * '66a581f618ee68dde53142c55e924d56cd2b2c169be5b374bc810ac692fb17fd'
   * ```
   *
   * ```shell
   * Successfully withdrew 2 BTC from your wallet! { id: '66a581f618ee68dde53142c55e924d56cd2b2c169be5b374bc810ac692fb17fd' }
   * ```
   */
  rpc WithdrawFunds (WithdrawFundsRequest) returns (WithdrawFundsResponse) {
    option (.google.api.http) = {
      post: "/v1/wallet/withdraw"
      body: "*"
    };
  }

  /**
   * CreateWallet creates a wallet within an engine. This RPC is used as during a 'first-use'
   * setup.
   *
   * When a broker daemon is first getting setup, no crypto-wallets will exist on any of
   * the provided engines. It is the user's responsiblity to create a wallet for each currency
   * and to save the backup information (password and cipher seeds) that are used and returned
   * from this method.
   *
   * ```javascript
   * const { recoverySeed } = await walletService.withdrawFunds({ symbol: 'BTC', password: 'your-secure-password')
   * console.log(recoverySeed)
   * ```
   *
   * ```shell
   * > sparkswap wallet create BTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * [ 'your',
   *   'cipher'
   *    ... ]
   * ```
   *
   * ```shell
   * > Please enter a password:
   * > Please confirm password:
   * IMPORTANT: Please make a copy of the recovery seed below as you WILL NOT
   * be able to recover this information again. We recommend that you write
   * down all the secret words, and re-confirm the order they are written down
   *
   * [ 'your',
   *   'cipher'
   *    ... ]
   * ```
   */
  rpc CreateWallet (CreateWalletRequest) returns (CreateWalletResponse) {
    option (.google.api.http) = {
      post: "/v1/wallet/create"
      body: "*"
    };
  }

  /**
   * UnlockWallet sends an unlock rpc command to the engine to allow funds to be used
   * in the event that the broker has been taken offline -> online
   *
   * This RPC will be required after every application restart, if each engine's wallet has been
   * created. If you need to create a wallet for daemon, please refer to `CreateWallet`
   *
   * ```javascript
   * await walletService.unlockWallet({ symbol: 'BTC', password: 'your-secure-password')
   * ```
   *
   * ```shell
   * > sparkswap wallet unlock BTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * {}
   * ```
   *
   * ```shell
   * Successfully Unlocked BTC Wallet!
   * ```
   */
  rpc UnlockWallet (UnlockWalletRequest) returns (google.protobuf.Empty) {
    option (.google.api.http) = {
      post: "/v1/wallet/unlock"
      body: "*"
    };
  }

  /**
   * WalletHistory returns all transactions for a specific wallet
   *
   * ```javascript
   * await walletService.walletHistory({ symbol: 'BTC' })
   * ```
   *
   * ```shell
   * > sparkswap wallet history BTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * { transactions:
   *    [ { type: 'DEPOSIT',
   *        amount: '2.00000000',
   *        transactionHash: '1063267467518d78ab56e439a6ec5d6b72eb2eca3ae5093d466beab3832e2dab',
   *        blockHeight: '122',
   *        timestamp: '1555479381',
   *        fees: '0.00000000',
   *        pending: false },
   *      { type: 'CHANNEL_OPEN',
   *        amount: '-0.16786002',
   *        transactionHash: 'c56d35e6b4fa661b52704d3516dc9c12b43e39c8c6e94996760ef4014a1c1669',
   *        blockHeight: '124',
   *        timestamp: '1555479401',
   *        fees: '0.00008787',
   *        pending: false },
   *     ...
   *   ]
   * }
   * ```
   *
   * ```shell
   *  ┌───────────────┬─────────────┬────────────┬────────────┬──────────────────────────────────────────────────────────────────┬────────┬─────────┐
   *  │ Type          │ Amount      │ Fees       │ Timestamp  │ Transaction                                                      │ Height │ Pending │
   *  ├───────────────┼─────────────┼────────────┼────────────┼──────────────────────────────────────────────────────────────────┼────────┼─────────┤
   *  │ DEPOSIT       │ 2.00000000  │ 0.00000000 │ 1555479381 │ 1063267467518d78ab56e439a6ec5d6b72eb2eca3ae5093d466beab3832e2dab │ 122    │ false   │
   *  ├───────────────┼─────────────┼────────────┼────────────┼──────────────────────────────────────────────────────────────────┼────────┼─────────┤
   *  │ CHANNEL_OPEN  │ -0.16786002 │ 0.00008787 │ 1555479401 │ c56d35e6b4fa661b52704d3516dc9c12b43e39c8c6e94996760ef4014a1c1669 │ 124    │ false   │
   *  ├───────────────┼─────────────┼────────────┼────────────┼──────────────────────────────────────────────────────────────────┼────────┼─────────┤
   *  │ CHANNEL_CLOSE │ 0.16768165  │ 0.00009050 │ 1555479471 │ 1960481be7a01df5c1b28e1fd24083fa7afe30dbff47c12c7fe30b448df11092 │ 131    │ false   │
   *  └───────────────┴─────────────┴────────────┴────────────┴──────────────────────────────────────────────────────────────────┴────────┴─────────┘
   * ```
  */
  rpc WalletHistory (WalletHistoryRequest) returns (WalletHistoryResponse) {
    option (.google.api.http) = {
      get: "/v1/wallet/summary/{symbol}"
    };
  }
}
