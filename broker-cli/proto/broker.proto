/**
 * This is the API definition for the Broker Daemon RPC Server.
 *
 * The Broker (or Broker Daemon) is an open source piece of software that allows anyone to
 * operate a node that keeps control of the private keys to their cryptocurrency (like Bitcoin and Litecoin)
 * and use [SparkSwap](http://sparkswap.com) to trade those currencies.
 *
 * The Broker runs as a daemon on a machine you control, and you direct it to take action through the RPC Server.
 * The Broker is responsible for translating typical trading behavior (e.g. market buys) into actions on the SparkSwap Relayer (e.g. a BTC/LTC swap on the Lightning Network).
 *
 * The Broker exposes a [gRPC service](http://grpc.io) which has support for [client libraries in many languages](https://grpc.io/about/#osp).
 *
 * The easiest way to interact with the Broker is through the [Broker CLI](https://github.com/sparkswap/broker-cli).
 *
 * For more information on the Broker, see:
 *
 *  - [Installing the BrokerDaemon](https://github.com/sparkswap/broker)
 *  - [Broker CLI](https://github.com/sparkswap/broker-cli)
 *  - [BrokerDaemon GitHub repository](https://github.com/sparkswap/broker)
 *
 * For more information on SparkSwap as a whole, see:
 *
 *  - [SparkSwap Homepage](https://sparkswap.com)
 *  - [SparkSwap Documentation](https://sparkswap.com/docs)
 *  - [SparkSwap Chat](https://sparkswap.com/chat)
 *
 * > Setting up to use the examples:
 *
 * ```javascript
 * // This documentation makes use of the grpc and grpc-caller libraries on npm.
 * // The remainder of the docs assumes this setup step.
 * const grpc = require('grpc')
 * const PROTO_OPTIONS = {
 *   convertFieldsToCamelCase: true,
 *   binaryAsBase64: true,
 *   longsAsStrings: true,
 *   enumsAsStrings: true
 * }
 * const brokerProto = grpc.load('/path/to/broker.proto', 'proto', PROTO_OPTIONS)
 * ```
 *
 * ```shell
 * > npm install -g https://github.com/sparkswap/broker-cli
 * > sparkswap -h
 * ```
 */
syntax = "proto3";

// import "google/protobuf/empty.proto";
// normally we would us the above import statement, but the node.js grpc doesn't import
// the standard types and so it throws an error message saying that it can't find google/protobuf.empty.proto
// Instead, we define our own Empty message that is equivalent.
message google {
    message protobuf {
        message Empty {
        }
    }
}

/**
 * Side is one of the two sides of any market.
 */
enum Side {
  // A BID is the buy side of a market.
  BID = 0;
  // An ASK is the sell side of a market.
  ASK = 1;
}

/**
 * HealthCheckResponse provides information on the health of a BrokerDaemon.
 */
message HealthCheckResponse {
  // The status of every engine available on the BrokerDaemon.
  repeated EngineStatus engine_status = 1;
  // The status of the relayer this BrokerDaemon is connected to, either `'OK'` or the error message returned when connecting to it.
  string relayer_status = 2;

  /**
   * EngineStatus provides the status of an engine for a currency.
   */
  message EngineStatus {
    // The common symbol that the engine is responsible for, e.g. `BTC` or `LTC`
    string symbol = 1;
    // The status of the engine, either `'OK'` or the error message returned when accessing it.
    string status = 2;
  }
}

/**
 * The AdminService performs administrative tasks on the BrokerDaemon.
 *
 * ```javascript
 * const address = 'localhost:27492'
 * const adminService = new brokerProto.AdminService(address, grpc.credentials.createInsecure())
 * ```
 */
service AdminService {
  /**
   * The HealthCheck returns a status of all of the components of the BrokerDaemon.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * adminService.healthCheck({}, { deadline }, (err, { engineStatus, relayerStatus }) => {
   *   if (err) return console.error(err)
   *   console.log({ engineStatus, relayerStatus })
   * })
   * ```
   *
   * ```shell
   * > sparkswap healthcheck
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * {
   *   "engineStatus": [
   *     {
   *       "symbol": "BTC",
   *       "status": "OK"
   *     },
   *     {
   *       "symbol": "LTC",
   *       "status": "OK"
   *     },
   *   ],
   *   "relayerStatus": "OK"
   * }
   * ```
   *
   * ```shell
   * HealthCheck: {
   *   "engines": {
   *     "BTC": "OK",
   *     "LTC": "OK"
   *   },
   *   "relayerStatus": "OK",
   *   "daemonStatus": "OK"
   * }
   * ```
   */
  rpc HealthCheck (google.protobuf.Empty) returns (HealthCheckResponse);
}

/**
 * The time restriction for an order given by the user to the Broker.
 * It is important to note that this time in force only controls the Broker's actions and does not correspond to a time-in-force on the underlying network.
 */
enum TimeInForce {
  GTC = 0; // Good-til-cancelled, an order that remains in force until cancelled by the user
  FOK = 1; // Fill-or-kill, an order that can be completely filled or will not be executed
  IOC = 2; // Immediate-or-cancel, an order that will have as much filled immediately as possible with the remainder cancelled
}

/**
 * Parameters to create a block order on the Broker.
 */
message CreateBlockOrderRequest {
  // The market to place the block order in, e.g. `'BTC/LTC'`. Markets are always expressed as the combination of two common symbols, separated by a `/`.
  string market = 1;
  // Side of the market that the user wishes to take.
  Side side = 2;
  // Amount, in common units for a currency (e.g. bitcoins for BTC) that is the size of the order. This field supports decimal representation of units but uses a string since protobuf lacks a decimal type (e.g. `'0.16'`)
  string amount = 3;
  oneof price_restriction {
    // Whether this order should be executed as a market order, i.e. at the best available price in the market. It is important to note that there is no concept of a Market Order in the underlying network. Instead, the Broker will simulate Market Order behavior by filling all orders in the market until the order is completely filled.
    bool is_market_order = 4;
    // Price at which this order should executed, represented as a decimal string due to lack of Protobuf decimal support (e.g. `'1.05'`).
    string limit_price = 5;
  }

  // Time restriction for this block order.
  TimeInForce time_in_force = 6;
}

/**
 * Response from the broker after creating a block order.
 */
message CreateBlockOrderResponse {
  // The unique ID of the block order assigned by the broker. This is used to retrieve information about the order and to cancel it.
  string block_order_id = 1;
}

/**
 * An order on the SparkSwap Relayer.
 */
message Order {

  /**
   * Status of an order on the SparkSwap Relayer.
   */
  enum OrderStatus {
    // The order has been created on the Relayer.
    CREATED = 0;
    // The order has been placed and communicated to other marker participants.
    PLACED = 1;
    // The order has been filled by another market participant.
    FILLED = 2;
    // The swap has been executed on the Payment Channel Networks
    EXECUTED = 3;
    // The swap preimage has been returned to the Relayer.
    COMPLETED = 4;
    // The order has encountered a failure.
    REJECTED = 5;
  }

  // Unique ID assigned by the Relayer for this order.
  string order_id = 1;
  // Status of the order on the Relayer.
  OrderStatus order_status = 2;
  // Amount of the order expressed in a decimal string of common units for a currency (e.g. bitcoins for BTC).
  string amount = 3;
  // Price at which the order was placed, expressed as a decimal string ratio between the common units of the currencies (e.g. litecoins to bitcoins, not litoshis to satoshis). All orders on the SparkSwap Relayer have prices.
  string price = 4;
  // Any error messages related to the status of a REJECTED or FAILED order
  string order_error = 6;
}

/**
 * A fill of an order on the SparkSwap Relayer.
 */
message Fill {

  /**
   * Status of the fill on the SparkSwap Relayer.
   */
  enum FillStatus {
    // The fill has been created on the Relayer.
    CREATED = 0;
    // The fill has been accepted as the fill for the given order.
    FILLED = 1;
    // The swap has been executed on the Payment Channel Networks.
    EXECUTED = 2;
    // The preimage has been returned to the Relayer by the Maker.
    COMPLETED = 3;
    // The fill has encountered a failure.
    REJECTED = 4;
  }
  // The Relayer-assigned unique ID of the order that this fill is for.
  string order_id = 1;
  // The Relayer-assignded unique ID for this fill.
  string fill_id = 2;
  // Status of the fill on the Relayer.
  FillStatus fill_status = 3;
  // Amount of the order to fill, expressed in a decimal string of common units for a currency (e.g. bitcoins for BTC). This can be any amount greater than zero and less than or equal to the amount in the order.
  string amount = 4;
  // Price at which the order was placed, expressed as a decimal string ratio between the common units of the currencies (e.g. litecoins to bitcoins, not litoshis to satoshis). All orders on the SparkSwap Relayer have prices.
  string price = 5;
  // Any error messages related to the status of a REJECTED or FAILED fill
  string fill_error = 6;
}

/**
 * An order placed by a user on a Broker.
 * These are called Block Orders because they are for (relatively) large blocks that get broken up into individual Orders and Fills on the Relayer.
 */
message BlockOrder {

  /**
   * Status of the block order on the Broker.
   */
  enum BlockOrderStatus {
    // The block order is still being worked by the Broker.
    ACTIVE = 0;
    // The block order was cancelled by the user.
    CANCELLED = 1;
    // The block order has successfully completed execution.
    COMPLETED = 2;
    // The block order has failed at some point and is no longer attempting execution.
    FAILED = 3;
  }

  // The unique ID for the block order assigned by the Broker.
  string block_order_id = 1;
  // The market that the block order is for, e.g. `'BTC/LTC'`. Markets are always expressed as the combination of two common symbols, separated by a `/`.
  string market = 2;
  // The side of the market that the block order is taking.
  Side side = 3;
  // Amount, in common units for a currency (e.g. bitcoins for BTC) that is the size of the order. This field supports decimal representation of units but uses a string since protobuf lacks a decimal type (e.g. `'0.16'`)
  string amount = 4;
  oneof price_restriction {
    // Whether this block order is/was executed as a market order, i.e. at the best available price in the market. It is important to note that there is no concept of a Market Order in the underlying network. Instead, the Broker will simulate Market Order behavior by filling all orders in the market until the order is completely filled.
    bool is_market_order = 13;
    // Price at which this order should executed, represented as a decimal string due to lack of Protobuf decimal support (e.g. `'1.05'`).
    string limit_price = 14;
  }

  // Time restriction for this block order.
  TimeInForce time_in_force = 5;
  // Current status of the block order.
  BlockOrderStatus status = 6;
}

/**
 * Parameters to retrieve a previously placed block order.
 */
message GetBlockOrderRequest {
  // ID for the block order assigned by the Broker.
  string block_order_id = 1;
}

/**
 * Representation of a retrieved block order.
 */
message GetBlockOrderResponse {
  // Status of the block order.
  BlockOrder.BlockOrderStatus status = 1;

  // The market that the block order is for, e.g. `'BTC/LTC'`. Markets are always expressed as the combination of two common symbols, separated by a `/`.
  string market = 10;
  // The side of the market that the block order is taking.
  Side side = 11;
  // Amount, in common units for a currency (e.g. bitcoins for BTC) that is the size of the order. This field supports decimal representation of units but uses a string since protobuf lacks a decimal type (e.g. `'0.16'`)
  string amount = 12;
  oneof price_restriction {
    // Whether this block order is/was executed as a market order, i.e. at the best available price in the market. It is important to note that there is no concept of a Market Order in the underlying network. Instead, the Broker will simulate Market Order behavior by filling all orders in the market until the order is completely filled.
    bool is_market_order = 13;
    // Price at which this order should executed, represented as a decimal string due to lack of Protobuf decimal support (e.g. `'1.05'`).
    string limit_price = 14;
  }
  // Time restriction for this block order.
  TimeInForce time_in_force = 15;

  // Amount of the block order that has been filled, in common units for a currency (e.g. bitcoins for BTC) represented as a decimal string (e.g. `'0.10'`)
  string fill_amount = 20;
  // All orders on the SparkSwap Relayer that were placed by the Broker in support of this block order.
  repeated Order open_orders = 21;
  // All fills of orders on the SparkSwap Relayer that were undertaken by the Broker in support of this block order.
  repeated Fill fills = 22;
}


/**
 * Request to cancel a previously created block order.
 */
message CancelBlockOrderRequest {
  // Unique ID for the block order as assigned by the Broker.
  string block_order_id = 1;
}

/**
 * All block orders in a given market.
 */
message GetBlockOrdersResponse {
  // A list of all block orders in the market.
  repeated BlockOrder block_orders = 1;
}

/**
 * Request to retrieve all block orders in a given market.
 */
message GetBlockOrdersRequest {
  // Market for which to retrieve block orders, expressed as a string separating two common symbols with a '/', e.g. `'BTC/LTC'`
  string market = 1;
}

/**
 * The OrderService manages all trading activity on the Broker.
 * It is the primary way that users interact with the Broker on a day-to-day basis.
 *
 * The OrderService deals primarily with block orders, which are instructions given to the Broker by the end-user and are executed by the Broker on the SparkSwap Network.
 * Brokers "work" block orders by breaking them into individual actions on the SparkSwap Relayer, namely placing limit orders and filling other participants' limit orders.
 * This separation between block orders worked by the Broker and the underlying orders on the SparkSwap Relayer allows users to get access to the features of orders they are accustomed to (e.g. market orders) without placing additional trust in the Relayer or exposing themselves to front-running.
 *
 * ```javascript
 * const address = 'localhost:27492'
 * const orderService = new brokerProto.OrderService(address, grpc.credentials.createInsecure())
 * ```
 */
service OrderService {
  /**
   * CreateBlockOrder creates new block orders on the Broker. This is the only way to initiate a trade on the broker.
   * Creating a block order returns a block order ID immediately, but that is not necessarily an indication that the block order has been successfully executed.
   * The user should check on the block order's status after it is created to understand if it has been completed.
   *
   * > Placing a market order:
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderService.createBlockOrder(
   *   {
   *     market: 'BTC/LTC', // trading BTC and LTC
   *     side: 'BID', // Place a buy order
   *     amount: '0.0001', // 0.0001 BTC being traded
   *     isMarketOrder: true, // use the best available price
   *     timeInForce: 'GTC' // execute this order until I cancel it
   *   },
   *   { deadline },
   *   (err, { blockOrderId }) => {
   *     if (err) return console.error(err)
   *     console.log({ blockOrderId })
   *   }
   * )
   * ```
   *
   * ```shell
   * > sparkswap buy 0.0001 --market BTC/LTC
   * ```
   *
   * > The above command will create a market block order on the Broker and will print:
   *
   * ```javascript
   * { "blockOrderId": "vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX" }
   * ```
   *
   * ```shell
   * { blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }
   * ```
   *
   * > Placing a limit order:
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderService.createBlockOrder(
   *   {
   *     market: 'BTC/LTC', // trading BTC and LTC
   *     side: 'BID', // Place a buy order
   *     amount: '0.0001', // 0.0001 BTC being traded
   *     limitPrice: '1.1', // at a price no worse than 1.1 LTC per BTC
   *     timeInForce: 'GTC' // execute this order until I cancel it
   *   },
   *   { deadline },
   *   (err, { blockOrderId }) => {
   *     if (err) return console.error(err)
   *     console.log({ blockOrderId })
   *   }
   * )
   * ```
   *
   * ```shell
   * > sparkswap buy 0.0001 1.1 --market BTC/LTC
   * ```
   *
   * > The above command will create a limit block order on the Broker and will print:
   *
   * ```javascript
   * { "blockOrderId": "o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs" }
   * ```
   *
   * ```shell
   * { blockOrderId: 'o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs' }
   * ```
   *
   */
  rpc CreateBlockOrder (CreateBlockOrderRequest) returns (CreateBlockOrderResponse);
  /**
   * GetBlockOrder returns information on a previously placed block order. It should be used to check on the status of placed block orders.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * const blockOrder = orderService.getBlockOrder({ blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }, { deadline }, (err, blockOrder) => {
   *   if (err) return console.error(err)
   *   console.log(blockOrder)
   * })
   * ```
   *
   * ```shell
   * > sparkswap order status vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX
   * ```
   *
   * > The above command will retrieve the block order on the Broker and will print:
   *
   * ```javascript
   * {
   *   "status": "",
   *   "market": "BTC/LTC",
   *   "side": "BID",
   *   "amount": "0.0001",
   *   "isMarketOrder": true,
   *   "timeInForce": "GTC",
   *   "open_orders": [],
   *   "fills": []
   * }
   * ```
   *
   * ```shell
   * { price_restriction: 'isMarketOrder',
   *   status: 'ACTIVE',
   *   market: 'BTC/LTC',
   *   side: 'BID',
   *   amount: '0.0001000000000000',
   *   isMarketOrder: true,
   *   limitPrice: '',
   *   timeInForce: 'GTC',
   *   fillAmount: '',
   *   openOrders: [],
   *   fills: [] }
   * ```
   */
  rpc GetBlockOrder (GetBlockOrderRequest) returns (GetBlockOrderResponse);
  /**
   * CancelBlockOrder cancels a previously placed block order.
   * If the block order is already completed, or consists only of orders that are already being filled (either by this Broker or a counterparty), this will have no effect, as the Broker is bound to complete those orders or else lose their deposit.
   * If the block order is partially executed, the cancel will affect only future actions, the Broker will not attempt to roll back trades that have already been made.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderService.getBlockOrder({ blockOrderId: 'vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX' }, { deadline }, (err) => {
   *   if (err) return console.error(err)
   * })
   * ```
   *
   * ```shell
   * > sparkswap order cancel vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX
   * ```
   *
   * > The above command will cancel the block order, but has no output.
   */
  rpc CancelBlockOrder (CancelBlockOrderRequest) returns (google.protobuf.Empty);
  /**
   * GetBlockOrders returns information on all of the block orders placed in a single market, like `BTC/LTC`.
   * It does not include complete information, such as the underlying orders and fills on the SparkSwap Relayer, or the amount of the order that has been filled. For that, use [GetBlockOrder](#getblockorder).
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * orderService.getBlockOrders({ market: 'BTC/LTC' }, { deadline }, (err, { blockOrders }) => {
   *   if (err) return console.error(err)
   *   console.log(blockOrders)
   * })
   * ```
   *
   * ```shell
   * > sparkswap order summary --market BTC/LTC
   * ```
   *
   * > The above command will retrieve the block orders on the Broker and will print:
   *
   * ```javascript
   * [
   *   {
   *     "status": "",
   *     "market": "BTC/LTC",
   *     "side": "BID",
   *     "amount": "0.0001",
   *     "isMarketOrder": true,
   *     "timeInForce": "GTC"
   *   },
   *   {
   *     "status": "",
   *     "market": "BTC/LTC",
   *     "side": "BID",
   *     "amount": "0.0001",
   *     "limitPrice": "1.1",
   *     "timeInForce": "GTC"
   *   }
   * ]
   * ```
   *
   * ```shell
   * ┌─────────────────────────────────────────────┬───────┬──────────────────┬──────────────────┬──────┬──────────┐
   * │ Order ID                                    │ Side  │ Amount           │ Limit Price      │ Time │ Status   │
   * ├─────────────────────────────────────────────┼───────┼──────────────────┼──────────────────┼──────┼──────────┤
   * │ o2tSlSibkCsw6zi4-mpVuMogeLaz_GZuGqJlhWVs    │ BID   │ 0.0001000000000… │ 1.1000000000000… │ GTC  │ ACTIVE   │
   * ├─────────────────────────────────────────────┼───────┼──────────────────┼──────────────────┼──────┼──────────┤
   * │ vQPeeYWTlpTPreJxE3My_mpTBiYwYPnTkd6aU2XX    │ BID   │ 0.0001000000000… │ MARKET           │ GTC  │ ACTIVE   │
   * └─────────────────────────────────────────────┴───────┴──────────────────┴──────────────────┴──────┴──────────┘
   * ```
   */
  rpc GetBlockOrders (GetBlockOrdersRequest) returns (GetBlockOrdersResponse);
}

/**
 * Request for updates in a given market.
 */
message WatchMarketRequest {
  // Market to retrieve updates for, e.g. `'BTC/LTC'`.
  string market = 1;
}

/**
 * An update to the watched market.
 */
message WatchMarketResponse {

  // Type of event this update is.
  EventType type = 1;
  // The market update
  MarketEvent market_event = 2;

  /**
   * Types of events, used to distinguish between adding orders to a market and removing them.
   */
  enum EventType {
      // Add an event to a market, typically due to an order being placed.
      ADD = 0;
      // Remove an event from the market, typically due to an order being cancelled or filled.
      DELETE = 1;
  }
}

/**
 * Market events are events that change the orderbook for a given market. The are a combination of orders, fills, and cancels.
 */
message MarketEvent {
  // The Relayer-assigned ID of the underlying order
  string order_id = 1;
  // Amount of the order expressed in a decimal string of common units for a currency (e.g. bitcoins for BTC).
  string amount = 2;
  // Price at which the order was placed, expressed as a decimal string ratio between the common units of the currencies (e.g. litecoins to bitcoins, not litoshis to satoshis). All orders on the SparkSwap Relayer have prices.
  string price = 3;
  // Side that the order is taking
  Side side = 4;
}

/**
 * The OrderBookService is intended to update users on network activity and provide an up to date orderbook for the user.
 *
 * It is the counterpoint to the [OrderService](#orderservice) in that it is read-only and deals with the wider network,
 * never touching the Block Orders that the user creates and cancels.
 *
 * ```javascript
 * const address = 'localhost:27492'
 * const orderBookService = new brokerProto.OrderBookService(address, grpc.credentials.createInsecure())
 * ```
 */
service OrderBookService {
  /**
   * WatchMarket opens a stream from the Broker with updates as to the current state of the orderbook.
   * Those updates come in the form of `ADD`s and `DELETE`s, so by updating a UI with those changes, the user can see the current state of the orderbook.
   * > Below is a simple example of a console-based UI for an orderbook:
   *
   * ```javascript
   * const call = orderBookService.watchMarket(request)
   * const orders = new Map()
   * call.on('data', (update) => {
   *   const { orderId, side, price, amount } = update.marketEvent
   *   const { type } = update
   *   if (type === EVENT_TYPES.DELETE) {
   *     orders.delete(orderId)
   *   } else {
   *     orders.set(orderId, { price, amount })
   *   }
   *   console.clear()
   *   console.log(Array.from(orders.values()).sort(function (a, b) { return parseFloat(a) - parseFloat(b) }))
   * })
   * ```
   *
   * ```shell
   * > sparkswap orderbook --market BTC/LTC
   * ```
   *
   * > After an update, the UI would show something like this:
   *
   * ```javascript
   * [
   *   {
   *     "side": "ASK",
   *     "price": "1.1",
   *     "amount": "0.0001"
   *   },
   *   {
   *     "side": "ASK",
   *     "price": "1.0",
   *     "amount": "0.0001"
   *   }
   * ]
   * ```
   *
   * ```shell
   * Market: BTC/LTC                                                                                                                            Ϟ SparkSwap Broker
   *                                                                                                                                           v0.1.0-alpha-preview
   *                                                                                                                                           http://sparkswap.com
   *
   * ┌──────────────────────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────┐
   * │ ASKS                                                                         │ BIDS                                                                         │
   * ├──────────────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────┤
   * │  Price                                Depth (BTC)                            │  Price                                Depth (BTC)                            │
   * │                                                                              │   1.2970000000000000                   0.0001000000000000                    │
   * │                                                                              │   1.2970000000000000                   0.0001000000000000                    │
   * │                                                                              │   1.1930000000000000                   0.0001000000000000                    │
   * │                                                                              │   1.1790000000000000                   0.0001300000000000                    │
   * │                                                                              │   1.1680000000000000                   0.0002000000000000                    │
   * │                                                                              │   1.1000000000000000                   0.0002000000000000                    │
   * └──────────────────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────┘
   *
   * ```
   */
  rpc WatchMarket (WatchMarketRequest) returns (stream WatchMarketResponse);
}

/**
 * Symbol is the common representation of a given currency.
 */
enum Symbol {
  // Bitcoin
  BTC = 0;
  // Litecoin
  LTC = 1;
}

/**
 * Request for a new address to send funds to for a given currency.
 */
message NewDepositAddressRequest {
  // Currency for which to generate the address
  Symbol symbol = 1;
}

/**
 * Created deposit address for a given currency.
 */
message NewDepositAddressResponse {
  // Address created.
  string address = 1;
}

/**
 * Balance in a currency in terms of what is committed in channels and total balance in wallets managed by this node.
 */
message Balance {
  // Currency of the balance.
  string symbol = 1;
  // Total balance of the wallets managed by this node in this currency, including balance in channels. This is currently in base units (e.g. Satoshi/Litoshis)
  int64 uncommitted_balance = 2;
  // Balance in the listed currency that is currently in channels. This is currently in base units (e.g. Satoshis/Litoshis)
  int64 total_channel_balance = 3;
  // Balance in the listed currency that is currently in pending channels. This is currently in base units (e.g. Satoshis/Litoshis)
  int64 total_pending_channel_balance = 4;
  // Balance in the listed currency that is currently in pending closing channels and unconfirmed wallet balance. This is currently in base units (e.g. Satoshis/Litoshis)
  int64 uncommitted_pending_balance = 5;
}

/**
 * All balances for a Broker.
 */
message GetBalancesResponse {
  // Balances in all currencies available to this Broker.
  repeated Balance balances = 1;
}

/**
 * Local and remote balances in the listed currency in the active, pending and inactive channels.
 */
message Capacity {
  // Currency of the balance.
  string symbol = 1;
  // Total active amount a user can send in the currency. This is currently in base units (e.g. Satoshi/Litoshis)
  string active_send_capacity = 2;
  // Total active amount a user can receive in the currency. This is currently in base units (e.g. Satoshis/Litoshis)
  string active_receive_capacity = 3;
  // Total pending amount a user can send in the currency. This is currently in base units (e.g. Satoshis/Litoshis)
  string pending_send_capacity = 4;
  // Total pending amount a user can receive in the currency. This is currently in base units (e.g. Satoshis/Litoshis)
  string pending_receive_capacity = 5;
  // Total inactive amount a user can send in the currency. This is currently in base units (e.g. Satoshis/Litoshis)
  string inactive_send_capacity = 6;
  // Total inactive amount a user can send in the currency. This is currently in base units (e.g. Satoshis/Litoshis)
  string inactive_receive_capacity = 7;
}

/**
 * Trading capacities for the base and counter currencies for a given market.
 */
message GetTradingCapacitiesResponse {
  // local and remote capacities in active, pending and inactive channels for the base currency
  Capacity base_symbol_capacities = 1;
  // local and remote capacities in active, pending and inactive channels for the counter currency
  Capacity counter_symbol_capacities = 2;
}

/**
 * Request to retrieve local and remote capacities in active, pending and inactive channels for a given market
 */
message GetTradingCapacitiesRequest {
  // Name of the market to retrieve capacities for
  string market = 1;
}

/**
 * Request to commit an amount of a given currency.
 */
message CommitBalanceRequest {
  // Currency of the balance to commit.
  Symbol symbol = 1;
  // Amount of the currency to commit. This is currently in base units (e.g. Satoshis/Litoshis)
  int64 balance = 2;
}

/**
 * Get the payment channel network address for a given currency.
 */
message GetPaymentChannelNetworkAddressRequest {
  // Currency for which to retrieve the address
  Symbol symbol = 1;
}

/**
 * Created deposit address for a given currency.
 */
message GetPaymentChannelNetworkAddressResponse {
  // Network Address retrieved
  string payment_channel_network_address = 1;
}

/**
 * The WalletService is for interacting with the wallets managed by the Broker on behalf of the user.
 *
 * It is used primarily during set up (e.g. making deposits) of a Broker.
 *
 * ```javascript
 * const address = 'localhost:27492'
 * const walletService = new brokerProto.WalletService(address, grpc.credentials.createInsecure())
 * ```
 */
service WalletService {
  /**
   * NewDepositAddress generates a new address for the user to deposit currency into to be used for trading.
   * The address is managed by a wallet in an underlying Payment Channel Network node, and so should be considered a hot wallet.
   *
   * ```javascript
   * const address = await walletService.newDepositAddress({ symbol: 'BTC' })
   * console.log(address)
   * ```
   *
   * ```shell
   * > sparkswap wallet new-deposit-address BTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * > TODO
   * ```
   *
   * ```shell
   * sb1qsakedujs4exdq5dz2cpldcph6hlvf82l8mn8uk
   * ```
   */
  rpc NewDepositAddress (NewDepositAddressRequest) returns (NewDepositAddressResponse);
  /**
   * GetBalances retrieves the balance in all currency in wallets managed by Payment Channel Network nodes for this Broker.
   *
   * Balances are divided into `uncommittedBalance`, i.e. everything not in a channel, `totalChannelBalance` (i.e. everything in channels opened by the Payment Channel Network nodes),
   * `totalPendingChannelBalance`, i.e. funds in channels that have finished the funding workflow and are waiting for confirmations for the funding txn, and
   * `uncommittedPendingBalance`, i.e funds in channels that are pending closure or unconfirmed unspent outputs under control of the wallet.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * walletService.getBalances({}, { deadline }, (err, { balances }) => {
   *   if (err) return console.error(err)
   *   console.log(balances)
   * })
   * ```
   *
   * ```shell
   * > sparkswap wallet balance
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * [
   *   {
   *     "symbol": "BTC",
   *     "uncommittedBalance": "1000000000",
   *     "totalChannelBalance": "16700000",
   *     "totalPendingChannelBalance": "10000",
   *     "uncommittedPendingBalance": "00000"
   *   },
   *   {
   *     "symbol": "LTC",
   *     "uncommittedBalance": "1000000000",
   *     "totalChannelBalance": "16700000",
   *     "totalPendingChannelBalance": "20000",
   *     "uncommittedPendingBalance": "00000"
   *   }
   * ]
   * ```
   *
   * ```shell
   * Wallet Balances
   * ┌──────────┬──────────────────────────────────┬──────────────────────────────────┐
   * │          │ Committed (Pending)              │ Uncommitted (Pending)            │
   * ├──────────┼──────────────────────────────────┼──────────────────────────────────┤
   * │ BTC      │ 0.1676816500000000 (0.00000000)  │ 9.8321513500000000 (0.00000000)  │
   * ├──────────┼──────────────────────────────────┼──────────────────────────────────┤
   * │ LTC      │ 0.0000000000000000 (0.00000000)  │ 10.0000000000000000 (0.00000000) │
   * └──────────┴──────────────────────────────────┴──────────────────────────────────┘
   * ```
   */
  rpc GetBalances (google.protobuf.Empty) returns (GetBalancesResponse);
  /**
   * CommitBalance opens a channel with the Relayer with the given amount of currency on the Broker's side, and requests that the Relayer open a channel to the Broker with the inverse currency of equivalent amount on the Relayer's side.
   * This allows the Broker to trade in the market, since it has an outgoing channel and an incoming channel.
   *
   * For now, since we operate a single market, `BTC/LTC`, this "inverse currency" is selected automatically - if you commit LTC, the Broker will request a BTC channel from the Relayer.
   *
   * Additionally, since the Network is in testing stages, rather than relying on the Network's exchange rate between BTC and LTC to determine how large of a channel to open, we use a set rate of 60 LTC to 1 BTC.
   * This also has the property of matching the conversion used in LND, so that when we run into things like the max channel size (in place while LND is in Beta), we can be consistent with LTC and BTC.
   *
   * > The below command has no output, but will throw an error if one is encountered.
   *
   * ```javascript
   * const deadline = new Date().setSeconds(new Date().getSeconds() + 5)
   * walletService.commitBalance(
   *   {
   *     // we are committing LTC to a channel.
   *     // The Broker will request a BTC channel be opened back to itself.
   *     symbol: 'LTC',
   *     // The amount (in Satoshis) to commit to the channel.
   *     // The Broker will request a BTC channel of size 16700000 / 60 be opened back to itself.
   *     balance: '16700000'
   *   },
   *   { deadline },
   *   (err) => {
   *     if (err) return console.error(err)
   *   }
   * )
   * ```
   *
   * ```shell
   * > sparkswap wallet commit-balance LTC
   * ```
   */
  rpc CommitBalance (CommitBalanceRequest) returns (google.protobuf.Empty);
  /**
   * GetPaymentChannelNetworkAddress retrieves the Payment Channel Network Address for the given currency.
   *
   * ```javascript
   * const { paymentChannelNetworkAddress } = await walletService.getPaymentChannelNetworkAddress({ symbol: 'BTC' })
   * console.log(paymentChannelNetworkAddress)
   * ```
   *
   * ```shell
   * > sparkswap wallet network-address BTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * > "025f08036e00e38468f52d68bb83939995440b72730bfaae99ace5630630997623@your.daemon:10113"
   * ```
   *
   * ```shell
   * 025f08036e00e38468f52d68bb83939995440b72730bfaae99ace5630630997623@your.daemon:10113
   * ```
   */
  rpc GetPaymentChannelNetworkAddress (GetPaymentChannelNetworkAddressRequest) returns (GetPaymentChannelNetworkAddressResponse);
  /**
   * GetTradingCapacities retrieves the remote and local capacities from the base and counter engines active, pending and inactive channels.
   *
   activeSendCapacity: Big(activeChannelCapacities.localBalance).div(divideBy).toString(),
   activeReceiveCapacity: Big(activeChannelCapacities.remoteBalance).div(divideBy).toString(),
   pendingSendCapacity: Big(pendingChannelCapacities.localBalance).div(divideBy).toString(),
   pendingReceiveCapacity: Big(pendingChannelCapacities.remoteBalance).div(divideBy).toString(),
   inactiveSendCapacity: Big(inactiveChannelCapacities.localBalance).div(divideBy).toString(),
   inactiveReceiveCapacity
   * Capacities are divided into three categories, active, pending and inactive. Each of these categories are further broken down into
   * the categories local and remote. For example, the activeSendCapacity is the local capacity in active channels for that engine, where pendingReceiveCapacity
   * is the remote capacity in pending channels for that engine. The response from GetTradingCapacities is a baseSymbolCapacities and counterSymbolCapacities
   * object where the respective capacities are grouped.
   *
   * ```javascript
   * walletService.getTradingCapacities({market: 'BTC/LTC}, (err, { baseSymbolCapacities, counterSymbolCapacities }) => {
   *   if (err) return console.error(err)
   *   console.log(baseSymbolCapacities)
   *   console.log(counterSymbolCapacities)
   * })
   * ```
   *
   * ```shell
   * > sparkswap wallet network-status --market BTC/LTC
   * ```
   *
   * > The above command will print:
   *
   * ```javascript
   * { "symbol": "BTC",
   *   "activeSendCapacity": "0.16768165",
   *   "activeReceiveCapacity": "0.0027057",
   *   "pendingSendCapacity": "0",
   *   "pendingReceiveCapacity": "0",
   *   "inactiveSendCapacity": "0",
   *   "inactiveReceiveCapacity": "0"
   * },
   * { "symbol": "LTC",
   *   "activeSendCapacity": "0.16741015",
   *   "activeReceiveCapacity": "10.065967",
   *   "pendingSendCapacity": "0",
   *   "pendingReceiveCapacity": "0",
   *   "inactiveSendCapacity": "0",
   *   "inactiveReceiveCapacity": "0"
   * }
   * ```
   *
   * ```shell
   * BTC/LTC
   * ┌──────────────┬────────────────────────┬────────────────────────┐
   * │              │ BTC Capacity           │ LTC Capacity           │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │ Active       │                        │                        │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Buy BTC    │ 0.0027057000000000     │ 0.1674101500000000     │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Sell BTC   │ 0.1676816500000000     │ 10.0659670000000000    │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │ Pending      │                        │                        │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Buy BTC    │ 0.0000000000000000     │ 0.0000000000000000     │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Sell BTC   │ 0.0000000000000000     │ 0.0000000000000000     │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │ Inactive     │                        │                        │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Buy BTC    │ 0.0000000000000000     │ 0.0000000000000000     │
   * ├──────────────┼────────────────────────┼────────────────────────┤
   * │   Sell BTC   │ 0.0000000000000000     │ 0.0000000000000000     │
   * └──────────────┴────────────────────────┴────────────────────────┘
   * ```
   */
  rpc GetTradingCapacities (GetTradingCapacitiesRequest) returns (GetTradingCapacitiesResponse);

}
